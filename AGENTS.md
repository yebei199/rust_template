# 通用规则
- 语言约定：内部思考和执行过程统一使用英文，仅在和用户沟通时使用中文。
- 文档同步更新：每次修改代码必须同步更新相关中文注释和 中文md 文档,比如文件顶部注释,项目结构、同级 doc
  目录下的文档,项目顶层docs注释。更新文档时注意压缩信息，而不是无限制增加细节，保持极致简洁。
- 目录文档：每个代码文件夹下必须包含一个 README.md，使用中文仅说明该目录的职责边界、设计意图与功能概述，高度概括,
  不能包含过多细节，以保持文档的简洁和可读性。
- 注释：无论是注释还是文档都要注意压缩信息，而不是无限制增加细节，在不丢失信息的情况保持简洁,没有冗余的细节信息。每个代码文件必须在顶部添加中文注释，说明该文件的设计意图和核心功能。注释内容应高度概括，避免过多细节。函数,
  以及关键字段或者其他注释同理.
- 变更确认机制：遇到需求模糊、存在多种实现方案、重大架构调整或破坏性变更时，必须先征求用户确认，禁止未征询明确指示就做假设或任意修改。
- 架构与职责：严格遵循单一职责原则。函数长度控制在 40 行以内，嵌套不超过 3 层，优先使用提前返回（Guard Clauses）降低心智负担。
- 数据与边界：处理逻辑前必须验证外部输入数据，显式处理所有边界条件。核心业务逻辑需包含测试用例，覆盖正常执行路径与极端边界情况。
- 硬编码与常量：绝对禁止代码中出现魔数或硬编码字符串。所有配置项、路径和固定值必须作为常量提取到函数外部。
- 语法与抽象：尽量使用高级抽象和语言特性简化代码，提高表达力。遵循社区最佳实践和习惯用法。
- 拆分文件: 每个文件长度禁止超过700行, 过长的文件需要进行合理拆分, 拆分时需要注意保持模块的内聚性和职责单一, 避免过度耦合.
# Rust专用规则
- 日志与错误监控：废弃标准 print 语句，统一采用结构化日志（如 debug 级别）。禁止静默捕获错误或保留空的错误处理块。需要断言成功时，必须包含清晰的错误描述。
- 模块组织：彻底禁用 mod.rs，采用与文件夹同名的外部模块文件（如使用 src/core.rs 而非 src/core/mod.rs）。模块结构清晰，可见性控制恰当。
- 语法与抽象：尽量使用高级抽象和语言特性（如 trait、模式匹配、函数式编程）简化代码，提高表达力。优先使用迭代器而非显式的 for 循环。遵循社区最佳实践和习惯用法。
- 性能与内存管理：遵循变量命名和所有权转移最佳实践。避免不必要的资源复制和内存分配（避免不必要的 Clone），在性能关键场景优化内存使用。
- 静态声明：所有配置项、路径与固定值统一使用 const 或 static 定义。
- 错误处理：优先使用 ? 操作符传播错误。禁止直接使用 unwrap()，必须断言时强制使用 expect() 并附带简明的错误描述。若遇特定 API 限制只能使用 unwrap 时（如迭代器的 next 方法），必须在函数的文档注释中明确说明原因。
- 安全界限：默认全面禁用 unsafe 特性。如遇特殊情况必须使用，必须附加详尽的代码注释，说明内存安全保证。
- 代码格式化：严格遵守 rustfmt 格式化标准，代码需符合 clippy 规范。
- 顶层文档注释：全部 rs 文件头部强制添加 //! 级别注释，仅阐述当前文件的设计意图。如需详尽说明，应在同级目录下建立 doc 文件夹及对应的 md 文档，保持代码文件简洁。
- API文档注释：所有重要的函数、类型、模块、结构体字段、枚举变量必须优先使用 /// 添加中文文档注释。注释要求高度概括，讲清楚目的，只需包含：设计意图、功能概述、参数意义。
